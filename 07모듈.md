# 📜 07 Managing Growing Projects with Packages, Crates, and Modules
[mod와 파일 시스템](#1-mod와-파일-시스템)&emsp;[pub](#2-pub으로-가시성-제어하기)&emsp;[use](#3-use로-이름-가져오기)
<br><br>

## 1. mod와 파일 시스템
자! 일단 새 바이너리 만드는 방법인 ```cargo new XXX --bin``` 명령어는 익숙함.<br>
이번엔 바이너리 크레이트를 만들지 않고 **라이브러리 크레이트**[^id]를 만든다고 함❗<br><br>
[2장 추리 게임 프로젝트](https://github.com/redzzzi/Rust23summer/blob/main/rustlang/02%EC%B6%94%EB%A6%AC%EA%B2%8C%EC%9E%84%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC.md)에서는 ```rand``` 라이브러리 크레이트 사용함.. 그랬었음....<br><br>
```communicator``` 라이브러리를 만들어볼거임<br>
⬆️ 몇 가지 일반적인 네트워크 기능 제공하는 라이브러리 뼈대 만드는 거임<br>
<pre>
$ cargo new communicator --lib
$ cd communicator
</pre>
리눅스 창<br>
<img src="https://github.com/redzzzi/Rust23summer/assets/127263392/308711dc-2401-442d-95ea-9a654e142327" width="500px">
* *src/main.rs* 대신 <b>*src/lib.rs*</b> 생성됨
<br>
src/lib.rs 파일을 열면<br>
<img src="https://github.com/redzzzi/Rust23summer/assets/127263392/273597ed-61c7-4555-b90d-d421c29feaf5" width="500px">
<br><br>
아래 코드 확인 가능

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
    }
}
```
* 라이브러리 작성 시작을 돕기 위해 만들어진 빈 테스트
* ```#[]```와 ```mod tests``` 문법이라는 것이 있다 ~
<br>
<pre>
<code>cargo run</code>에서는 <i>src/main.rs</i> 파일만을 기본적으로 실행시키기 때문에,<br>현재 위치에서는 해당 커맨드로 카고가 실행할 것이 없음<br><br>&emsp;➡️ 라이브러리 크레이트 코드 컴파일 하기 위해 <code>cargo build</code> 사용
</pre>

## 모듈 정의
* 러스트 내 모듈 정의는 ```mod```로 시작

#### 이제 ```connect```라는 이름의 함수가 정의된 ```network```라는 이름의 모듈을 정의해볼거임
1. src/lib.rs 시작 부분인 테스트 코드 위쪽에 아래 코드 추가

   ```rust
   mod network {
       fn connect() {
       }
   }
   ```
   * ```mod``` 키워드 뒤에, 모듈 이름(```network```)이 쓰여짐
   * 중괄호 안에 코드 블럭 위치 → ```network``` 안에 속함
   * ```connect``` 함수를 ```network``` 모듈 바깥 스크립트에서 호출하고자 한다❗❓<br>
     ➡️ 모듈 특정할 필요 있으므로 *이름공간 문법*```::```을 이용해야 함. ex) ```network::connect()```
     
#### 파일 내에 여러 개 모듈 정의 가능함
2. ```connect```라는 함수를 가진 또 다른 모듈 ```cliet``` 정의

   ```rust
   mod network {
       fn connect() {
       }
   }
  
   mod client {
       fn connect() {
       }
   }
   ```
   * ```network::connect``` 함수와 ```client::connect``` 함수를 가지게 되는거임
   * 서로 다른 모듈에 정의돼 있어 함수 이름이 충돌할 일 ❌

#### src/main.rs 내에도 위와 같은 방법으로 모듈 생성 가능

#### 모듈 안에 모듈 ~~안에 모듈 안에 모듈 안에 모듈 ............~~ 생성하기
3. ```client``` 모듈을 ```network``` 모듈 안으로 이동

   ```rust
   mod network {
       fn connect() {
       }
   
       mod client {
           fn connect() {
           }
       }
   }
   ```
   * ```network::connect```와 ```network::client::connect``` 함수를 갖게 됨 ㅎㅎ❗

#### 모듈의 계층 구성

*src/lib.rs*의 내용이 가장 위의 층, 서브 모듈은 그보다 낮은 층.
<br>

<details>
<summary>나란한 module의 계층</summary>
<div markdown="1">

<br> 
<pre>
communicator
 ├── network
 └── client
</pre>

코드
```rust
mod network {
    fn connect() {
    }
}

mod client {
    fn connect() {
    }
}
```
</details>

<details>
<summary>중첩된 module의 계층</summary>
<div markdown="1">

<br>
<pre>
communicator
 └── network
     └── client
</pre>

코드
```rust
mod network {
    fn connect() {
    }

    mod client {
        fn connect() {
        }
    }
}
```
</details>

## 모듈을 다른 파일로 옮기기
러스트에서는 프로젝트를 세분화하기 위해, 여러 개의 파일 상에서 모듈 시스템을 사용할 수 있음<br>(== *src/lib.rs*나 *src/main.rs* 안에 존재하지 않도록)

#### 세 모듈 ```client```, ```network```, ```network::server``` 모두 *src/lib.rs*에 정의됨
```rust
mod client {
    fn connect() {
    }
}

mod network {
    fn connect() {
    }

    mod server {
        fn connect() {
        }
    }
}
```

##### ↪️ 모듈 계층
<pre>
communicator
 ├── client
 └── network
     └── server
</pre> 
<br>
<pre>
함수의 개수, 함수의 코드라인이 많아지고 길어지면서 파일 스크롤 까다로워짐<br>
🤓 <b>server</b> 모듈을 <i>src/lib.rs</i>로부터 떼어내어 각각 파일에 위치시킬 수 있음 🤓
</pre>

## 모듈 파일 시스템의 규칙

<br><br>

## 2. pub으로 가시성 제어하기
<br><br>

## 3. use로 이름 가져오기



[^id]: 다른 사람들이 자신들의 프로젝트에 dependency로 추가할 수 있는 프로젝트.
