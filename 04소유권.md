4th. Understanding Ownership
=============
[1. what the ownership is](#1-소유권이-뭔가요)<br>
[2. reference and borrowing](#2-참조자와-빌림)<br>
[3. the slice type](#3-슬라이스)<br>
<br>
<br>
<br>

# 1. 소유권이 뭔가요?
뭔데.....................
## 스택
* <i><b>last in, first out</b></i>: 받아들인 순서대로 값을 저장 🔁 반대 방향으로 값을 지움

* (데이터 추가) pushing on the stack ↔️ popping off the stack (데이터 제거)

* 데이터 공간이 항상 스택의 꼭대기로 지정 ➡️ 공간 검색할 필요 없어, 빠름

* 스택의 데이터는 고정된 크기를 지녀야 함
## 힙
* 크기 변경 가능한 데이터

* allocating on the heap<br>
  1️⃣저장 공간 확인 2️⃣OS가 빈 지점을 찾아 '사용중'으로 표시 3️⃣해당 지점의 포인터 반환

* 포인터 위치 따라가야 해서 속도 느림
## ⭐소유권 규칙⭐
1. 러스트 각 값은 해당값의 owner라 불리는 변수를 가짐
2. 한번에 하나의 오너만 존재 가능
3. 오너가 스코프 밖으로 벗어날 때, 값이 버려짐

* Variable Scope: 변수가 유효한 범위를 나타내는 거. ```{ }```

* 스코프에서 벗어나면 힙 메모리 무효화 ➡️ 버그 방지

* Variables and Data Interacting with Move
  ```rust
  let s1 = String::from("hello");
  let s2 = s1;

  println!("{}, world!", s1);
  ```
  ```rust
  $ cargo run
     Compiling ownership v0.1.0 (file:///projects/ownership)
  error[E0382]: borrow of moved value: `s1`
   --> src/main.rs:5:28
    |
  2 |     let s1 = String::from("hello");
    |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
  3 |     let s2 = s1;
    |              -- value moved here
  4 |
  5 |     println!("{}, world!", s1);
    |                            ^^ value borrowed here after move
    |
    = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
  help: consider cloning the value if the performance cost is acceptable
    |
  3 |     let s2 = s1.clone();
    |                ++++++++
  
  For more information about this error, try `rustc --explain E0382`.
  error: could not compile `ownership` due to previous error
  ```
  ➡️ 에러 엔딩 ```REASON``` s1의 ownership이 s2로 move되면, s1 사용 불가.
  
# 2. 참조자와 빌림
# 3. 슬라이스
