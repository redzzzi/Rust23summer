# ğŸ“œ 06 Enums and Pattern Matching
[ì—´ê±°í˜• ì •ì˜](#1-ì—´ê±°í˜•-ì •ì˜í•˜ê¸°)&emsp;[match](#2-match-íë¦„-ì œì–´-ì—°ì‚°ì)&emsp;[if let íë¦„ ì œì–´](#3-if-letì„-ì‚¬ìš©í•œ-ê°„ê²°í•œ-íë¦„-ì œì–´)
<br><br>

## 1. ì—´ê±°í˜• ì •ì˜í•˜ê¸°
ì—´ê±°í˜•ì˜ variants
```rust
enum IpAddrKind {
    V4,
    V6,
}
```
* ë‚˜ì—´ *enumerate* == ì—´ê±°
<br><br>

### ì—´ê±°í˜• ê°’
```IpAddrKind```ì˜ variantsì— ëŒ€í•œ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
```rust
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
```
<br>

```IpAddrKind``` íƒ€ì…ì„ ì¸ìë¡œ ë°›ëŠ” í•¨ìˆ˜ ì •ì˜
```rust
fn route(ip_type: IpAddrKind) { }
```
<br>

variant ì¤‘ í•˜ë‚˜ë¥¼ ì‚¬ìš©í•´ í•¨ìˆ˜ í˜¸ì¶œ
```rust
route(IpAddrKind::V4);
route(IpAddrKind::V6);
```
<br>
<details>
<summary>êµ¬ì¡°ì²´ë¡œ í•´ê²°</summary>
<div markdown="1">
  
```rust
enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from("127.0.0.1"),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from("::1"),
};
```
* ë‘ ê°œì˜ í•„ë“œ(kind, address)ë¥¼ ê°–ëŠ” ```IPAddr``` ì •ì˜
</details>
<details>
<summary>ì—´ê±°í˜•ìœ¼ë¡œ í•´ê²°</summary>
<div markdown="1">

```rust
enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));

let loopback = IpAddr::V6(String::from("::1"));
```
* ì—´ê±°í˜• variantì— ì§ì ‘ ë°ì´í„° ë¶™ì„
* ë˜í•œ ```V4``` ì£¼ì†Œì—ëŠ” 4ê°œì˜ ```u8``` ê°’ì„ ì €ì¥í•˜ê³ , ```V6``` ì£¼ì†Œì—ëŠ” í•˜ë‚˜ì˜ ```String``` ê°’ìœ¼ë¡œ í‘œí˜„í•˜ëŠ” ê²ƒ ê°€ëŠ¥â— (êµ¬ì¡°ì²´ëŠ” ë¶ˆê°€)
  ```rust
  enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
  }

  let home = IpAddr::V4(127, 0, 0, 1);
  
  let loopback = IpAddr::V6(String::from("::1"));
  ```

</details>
<br>

[IP ì£¼ì†Œ ê´€ë ¨ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì •ì˜](https://doc.rust-lang.org/std/net/enum.IpAddr.html)
```rust
struct Ipv4Addr {
    // details elided
}

struct Ipv6Addr {
    // details elided
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
```
<br>
<details>
<summary>ì—´ê±°í˜•ì˜ ë‹¤ë¥¸ ì˜ˆì œ</summary>
<div markdown="1">

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```
* ë‹¤ë¥¸ ë°ì´í„° íƒ€ì…ì„ ê°–ëŠ” ë„¤ ê°œì˜ variants
    * ```Quit```: ì—°ê´€ ë°ì´í„° âŒ
    * ```Move```: ìµëª… êµ¬ì¡°ì²´ í¬í•¨
    * ```Write```: í•˜ë‚˜ì˜ ```String``` í¬í•¨
    * ```ChangeColor```: ì„¸ ê°œì˜ ```i32``` í¬í•¨
* ```struct``` í‚¤ì›Œë“œ ë¯¸ì‚¬ìš©
* ëª¨ë“  variantsê°€ ```Message``` íƒ€ì…ìœ¼ë¡œ ê·¸ë£¹í™”
<br>
ìœ„ì™€ ë™ì¼í•œ variantsì˜ ë°ì´í„°ë¥¼ í¬í•¨í•˜ëŠ” ì½”ë“œ

```rust
struct QuitMessage; // ìœ ë‹› êµ¬ì¡°ì²´
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // íŠœí”Œ êµ¬ì¡°ì²´
struct ChangeColorMessage(i32, i32, i32); // íŠœí”Œ êµ¬ì¡°ì²´
```
* ë©”ì‹œì§€ ì¤‘ ì–´ë–¤ í•œ ê°€ì§€ë¥¼ ì¸ìë¡œ ë°›ëŠ” í•¨ìˆ˜ ì •ì˜ ê°€ëŠ¥ (âˆµ ```Message``` ì—´ê±°í˜•ì€ í•˜ë‚˜ì˜ íƒ€ì…)

</details>
<br>

### ë©”ì†Œë“œ ì •ì˜ê°€ ê°€ëŠ¥í•œ ì—´ê±°í˜•
```rust
impl Message {
    fn call(&self) {
        // ë©”ì†Œë“œ ë‚´ìš©ì€ ì—¬ê¸° ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    }
}

let m = Message::Write(String::from("hello"));
m.call();
```
* ì—´ê±°í˜• ê°’ ê°€ì ¸ì˜¤ê¸° ìœ„í•´ ë©”ì†Œë“œ ë‚´ì—ì„œ ```self``` ì‚¬ìš©
* ```m.call()``` ì‹¤í–‰ â¡ï¸ ```m```ì˜ ê°’ì´ ```Message::Write(String::from("hello"))```ì—ì„œ ```call``` ë©”ì†Œë“œ ë‚´ì—ì„œ ```self```ê°€ ë¨.
<br>

### Options ì—´ê±°í˜• ê·¸ë¦¬ê³  ì´ê²ƒì´ Nullê°’ë³´ë‹¤ ì¢‹ì€ ì  
* ```Option``` íƒ€ì…ì€ *ê°’ì´ ìˆê±°ë‚˜ ì—†ì„ ìˆ˜ë„ ìˆëŠ”* ì•„ì£¼ í”í•œ ìƒí™©ì„ ë‚˜íƒ€ë‚´ê¸° ë•Œë¬¸ì—, íƒ€ì… ì‹œìŠ¤í…œì˜ ê´€ì ì—ì„œ **ì»´íŒŒì¼ëŸ¬ê°€ ë°œìƒí•  ìˆ˜ ìˆëŠ” ëª¨ë“  ê²½ìš°ë¥¼ ì²˜ë¦¬í–ˆëŠ”ì§€** ì²´í¬í•  ìˆ˜ ìˆìŒâ—
* ëŸ¬ìŠ¤íŠ¸ì—ëŠ” null íŠ¹ì„±ì´ ì—†ìŒ
<br>

[Option<T> í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì •ì˜](https://doc.rust-lang.org/std/option/enum.Option.html)
```rust
enum Option<T> {
    Some(T),
    None,
}
```
* ```Option<T>``` ì—´ê±°í˜•ì€ ê¸°ë³¸ì ìœ¼ë¡œ í¬í•¨ë¨ â†’ ëª…ì‹œ ì•ˆí•˜ê³ ë„ ë°”ë¡œ ì‚¬ìš© ê°€ëŠ¥
    * ```Option::```ì„ ì•ì— ë¶™ì´ì§€ ì•Šê³  ```Some```ê³¼ ```None```ì˜ variants ì‚¬ìš©
<br>

**\<T>ì˜ ê¸°ëŠ¥**
* ```Option``` ì—´ê±°í˜•ì˜ ```Some``` variantsê°€ ì–´ë–¤ íƒ€ì…ì˜ ë°ì´í„°ë¼ë„ ê°€ì§ˆ ìˆ˜ ìˆê²Œ í•¨
* ëŸ¬ìŠ¤íŠ¸ ë¬¸ë²•
* [ì œë„ˆë¦­ íƒ€ì…](https://rinthel.github.io/rust-lang-book-ko/ch10-01-syntax.html) íŒŒë¼ë¯¸í„°
<details>
<summary>ìˆ«ì íƒ€ì…ê³¼ ë¬¸ìì—´ íƒ€ì… ê°–ëŠ” <code>Option</code>ê°’ì— ëŒ€í•œ ì˜ˆ</summary>
<div markdown="1">

```rust
let some_number = Some(5);
let some_string = Some("a string");

let absent_number: Option<i32> = None;
```
* ```Some``` ê°’ ì–»ê²Œ ë˜ë©´, 1ï¸âƒ£ ê°’ì´ ìˆìŒ 2ï¸âƒ£ ```Some```ì´ ê°–ê³  ìˆëŠ” ê°’ì— ëŒ€í•´ ì•Œ ìˆ˜ ìˆìŒ
* ```None```ì€ nullì˜ ì˜ë¯¸ë¥¼ ê°€ì§€ê²Œ ë˜ì–´ ìœ íš¨í•˜ì§€ ì•ŠìŒ
</details>

#### ê·¸ë˜ì„œ ì´ê²Œ nullì¸ ê²ƒë³´ë‹¤ ì¢‹ì€ ì´ìœ 
```rust
let x: i8 = 5;
let y: Option<i8> = Some(5);

let sum = x + y;
```
ì—ëŸ¬ ë©”ì‹œì§€
<pre>
error[E0277]: the trait bound `i8: std::ops::Add<std::option::Option<i8>>` is
not satisfied
 -->
  |
7 | let sum = x + y;
  |           ^^^^^
  |
</pre>
* ì¼ë‹¨ ìœ„ ì½”ë“œëŠ” ```Option<i8>```ì— ```i8```ì„ ë”í•˜ë ¤ê³  í•´ì„œ ì»´íŒŒì¼ ë˜ì§€ ì•ŠìŒ<br>
  â¡ï¸ ì»´íŒŒì¼ëŸ¬ì—ì„œ ìœ„ì˜ ```Option<i8>```ì²˜ëŸ¼ ìœ íš¨í•˜ê²Œ ì‚¬ìš©í•˜ì§€ ëª»í•˜ê²Œ í•¨
* ```Option<T>```ì™€ ```<T>```(ğŸ…ì–´ë–¤ íƒ€ì…ì´ë“  ë  ìˆ˜ ìˆìŒ)ëŠ” ë‹¤ë¥¸ íƒ€ì…ì„
* ìœ„ ì½”ë“œì—ì„œëŠ” ì—ëŸ¬ê°€ ëœ¨ì§€ë§Œ, **ëŸ¬ìŠ¤íŠ¸ì—ì„œ ```i8```ê³¼ê°™ì€ íƒ€ì…ì˜ ê°’ì„ ê°€ì§ˆ ë•Œ nullì¸ì§€ í™•ì¸í•  í•„ìš” ì—†ì´ ì‚¬ìš© ê°€ëŠ¥**
* ìœ„ê°™ì€ ê²½ìš°ì—ì„œëŠ” ê°’ì˜ ì¡´ì¬ ì—¬ë¶€ì— ëŒ€í•´ ìƒê°í•´ë´ì•¼í•¨
* ```T``` ëŒ€í•œ ì—°ì‚° ìˆ˜í–‰ ì „ ```Option<T>```ë¥¼ ```T```ë¡œ ë³€í™˜í•´ì•¼ í•¨
* nullì¼ ìˆ˜ ìˆëŠ” ê°’ì„ ì‚¬ìš©í•˜ê¸° ìœ„í•´ ëª…ì‹œì ìœ¼ë¡œ ê°’ì˜ íƒ€ì…ì„ ```Option<T>```ë¡œ ë§Œë“¤ê¸°
<br>

## 2. match íë¦„ ì œì–´ ì—°ì‚°ì

### ```match```
* ê°•ë ¥í•œ íë¦„ ì œì–´ ì—°ì‚°ì
* ì¼ë ¨ì˜ íŒ¨í„´ì— ëŒ€í•´, ì–´ë–¤ ê°’ì„ ë¹„êµí•˜ê³  ì–´ë–¤ íŒ¨í„´ì— ë§¤ì¹˜ë˜ì—ˆëŠ”ì§€ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì½”ë“œ ìˆ˜í–‰ ë„ì›€
* íŒ¨í„´ì„ êµ¬ì„±í•˜ëŠ” ê²ƒì—ëŠ” ë¦¬í„°ëŸ´ ê°’, ë³€ìˆ˜ëª…, ì™€ì¼ë“œ ì¹´ë“œ ë“±ì´ ìˆìŒ
  <details>
  <summary>ìì„¸íˆ</summary>
  <div markdown="1">

  ```ì½”ë“œ ì¶œì²˜: chatGPT```
  1. ë¦¬í„°ëŸ´ ê°’: íŠ¹ì •í•œ ê°’ ìì²´
     * ìˆ«ì, ë¬¸ìì—´, ë¶ˆë¦¬ì–¸ ê°’, etc.
     ```rust
     let number = 42;
     match number {
         0 => println!("The number is zero"),
         1 => println!("The number is one"),
     }
     ```
  2. ë³€ìˆ˜ëª…
     * íŒ¨í„´ ë§¤ì¹­ ì‹œ ê°’ì„ ë°”ì¸ë”© í•˜ëŠ” ë° ì‚¬ìš©ë¨.
     * ë§¤ì¹­í•˜ëŠ” ê°’ì´ í•´ë‹¹ ë³€ìˆ˜ì— í• ë‹¹ë¨. â†’ ê°’ ì¶”ì¶œ, í™œìš©
     ```rust
     let point = (3, 4);
     match point {
         (x, y) => println!("The point is at coordinates: ({}, {})", x, y),
     }
     ```
  3. ì™€ì¼ë“œì¹´ë“œ: ì–´ë–¤ ê°’ì—ë„ ë§¤ì¹˜ë˜ëŠ” íŠ¹ë³„í•œ íŒ¨í„´.
     * ```_``` ê¸°í˜¸ë¡œ í‘œì‹œ.
     * íŠ¹ì • ê°’ì— ê´€ì‹¬ì´ ì—†ê±°ë‚˜ ì‚¬ìš©í•˜ì§€ ì•Šì„ ë•Œ ìœ ìš©í•¨b.
     ```rust
     let number = 42;
     match number {
         _ => println!("I don't care about the value"),
     }
     ```
  </details>
<br>

### ğŸª™ë™ì „ ì˜ˆì œğŸª™
ë¯¸êµ­ ë™ì „ì„ ì…ë ¥ë°›ì•„, ì–´ë–¤ ë™ì „ì¸ì§€ì™€ ì„¼íŠ¸ë¡œ ë°˜í™˜í•˜ê¸°
```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u32 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

<details>
<summary>â•chatGPTê°€ ë§Œë“¤ì–´ì¤€ ì½”ë“œâ•</summary>
<div markdown="1">

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn identify_coin_and_return_value(coin: Coin) -> Option<u32> {
    match coin {
        Coin::Penny => Some(1),
        Coin::Nickel => Some(5),
        Coin::Dime => Some(10),
        Coin::Quarter => Some(25),
    }
}

fn main() {
    let penny = Coin::Penny;
    let nickel = Coin::Nickel;
    let dime = Coin::Dime;
    let quarter = Coin::Quarter;

    if let Some(value) = identify_coin_and_return_value(penny) {
        println!("This is a penny worth {} cents.", value);
    }
    if let Some(value) = identify_coin_and_return_value(nickel) {
        println!("This is a nickel worth {} cents.", value);
    }
    if let Some(value) = identify_coin_and_return_value(dime) {
        println!("This is a dime worth {} cents.", value);
    }
    if let Some(value) = identify_coin_and_return_value(quarter) {
        println!("This is a quarter worth {} cents.", value);
    }
}
```
<br>
ì¶œë ¥ë¬¸<br>
<img src = "https://github.com/redzzzi/Rust23summer/assets/127263392/75597c97-4646-42d3-94e9-9d6e72542732" width="400px">

</details>

* ì—´ê±°í˜•ê³¼ ì—´ê±°í˜• variantë¥¼ íŒ¨í„´ìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” ```match``` í‘œí˜„ì‹ì„
* ```match``` í‚¤ì›Œë“œ ë’¤ ```coin``` íƒ€ì…ì€ ```Coin``` ì—´ê±°í˜•ì„
* ```match```ì˜ ê°ˆë˜ë“¤
    * í•˜ë‚˜ì˜ ê°ˆë˜ = ```íŒ¨í„´``` + ```ì½”ë“œ```
    * ê° ê°ˆë˜ëŠ” ê·¸ ë‹¤ìŒ ê°ˆë˜ì™€ ì‰¼í‘œë¡œ êµ¬ë¶„
    * ```Coin::Penny => 1,```ì—ì„œ,<br>
      ```Coin::Penny```ì˜ íŒ¨í„´ì„ ê°€ì§€ë©° ```=>``` ì—°ì‚°ìë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì‹¤í–‰ë˜ëŠ” ì½”ë“œ(ê°’ ```1```)ë¥¼ ì•Œ ìˆ˜ ìˆìŒ.
    * ```=>```: íŒ¨í„´ê³¼ ì‹¤í–‰ë˜ëŠ” ì½”ë“œë¥¼ êµ¬ë¶„í•´ì£¼ëŠ” ì—°ì‚°ì
* ```match``` í‘œí˜„ì‹ ì‹¤í–‰ ì‹œ, ê²°ê³¼ê°’ì„ ê° ê°ˆë˜ì˜ íŒ¨í„´ê³¼ ìˆœì°¨ ë¹„êµ.<br>
  ğŸ¤“ **ì–´ë–¤ íŒ¨í„´ì´ ê·¸ ê°’ì´ë‘ ë§¤ì¹˜ëœë‹¤** â¡ï¸ ê·¸ íŒ¨í„´ê³¼ ì—°ê´€ëœ ì½”ë“œ ì‹¤í–‰<br>
  ğŸ¤“ **ë§¤ì¹˜ë˜ì§€ ì•ŠëŠ”ë‹¤** â¡ï¸ ë‹¤ìŒ ê°ˆë˜ë¡œ ê³„ì† ì‹¤í–‰
* ì‹¤í–‰í•˜ê³ ì í•˜ëŠ” ì½”ë“œê°€ ì—¬ëŸ¬ ì¤„ì´ë¼ë©´ ì¤‘ê´„í˜¸ ì‚¬ìš©.<br>
  ì˜ˆì‹œ
  ```rust
  fn value_in_cents(coin: Coin) -> u32 {
      match coin {
          Coin::Penny => { // <- ì¤‘ê´„í˜¸ ì‹œì‘
              println!("Lucky penny!");
              1
          },  // <- ì¤‘ê´„í˜¸ ëë
          Coin::Nickel => 5,
          Coin::Dime => 10,
          Coin::Quarter => 25,
      }
  }
  ```
<br>

### ê°’ë“¤ì„ ë°”ì¸ë”©í•˜ëŠ” íŒ¨í„´
* ë§¤ì¹˜ ê°ˆë˜ì˜ ê¸°ëŠ¥ â•: íŒ¨í„´ê³¼ ë§¤ì¹˜ëœ ê°’ë“¤ì˜ ë¶€ë¶„ ë°”ì¸ë”©(ë³€ìˆ˜ì— ê°’ í• ë‹¹í•˜ê¸°) ê°€ëŠ¥
<br>

*1999~2008ë…„, ë¯¸êµ­ì€ ê° 50ê°œ ì£¼ë§ˆë‹¤ í•œìª½ ë©´ì˜ ë””ìì¸ì´ ë‹¤ë¥¸ **ì¿¼í„° ë™ì „** ì£¼ì¡°*<br>

â¡ï¸ ```Quarter``` variant ë‚´ì— ```UsState``` ê°’ì„ í¬í•¨í•˜ë„ë¡ ì—´ê±°í˜•```enum``` ë³€ê²½í•¨ìœ¼ë¡œì¨ ì¶”ê°€í•  ìˆ˜ ìˆìŒâ—

```rust
#[derive(Debug)] // So we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // ... etc
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
```

* ìœ„ì—ì„œ ì–¸ê¸‰ëœ ë°”ì™€ ê°™ì´, ```Coin``` ì—´ê±°í˜•ì—ì„œ ```Quarter``` variantê°€ ```UsState```ê°’ ë˜í•œ ë“¤ê³  ìˆìŒ
<br>

ì¿¼í„° ë™ì „ë§ˆë‹¤ ì£¼ ì´ë¦„ì„ ì¶œë ¥í•˜ë ¤ë©´? â¡ï¸ ```state``` ë³€ìˆ˜ ì¶”ê°€í•´ì£¼ë©´ ë¨<br>

ì•„ë˜ ì½”ë“œë¥¼ ìœ„ ì½”ë“œì— ì¶”ê°€
```rust
fn value_in_cents(coin: Coin) -> u32 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        },
    }
}
```
* ```value_in_cents(Coin::Quarter(UsState::Alaska))```ì„ í˜¸ì¶œí–ˆì„ ë•Œ, ```coin```ì€ ```Coin::Quarter(UsState::Alaska)```ì— í•´ë‹¹.
* ê°ê°ì˜ ë§¤ì¹˜ ê°ˆë˜ì™€ í•´ë‹¹ ê°’ì„ ë¹„êµí•˜ì—¬ ```Coin::Quarter(state)```ì— ë„ë‹¬í•  ë•Œê¹Œì§€ ë§¤ì¹˜ âŒ
* ```state```ì— ëŒ€í•œ ë°”ì¸ë”© ê°’ == ```UsState::Alaska```<br>
  â¡ï¸ í•´ë‹¹ ë°”ì¸ë”©ì„ ```println!``` í‘œí˜„ì‹ ë‚´ ì‚¬ìš© ê°€ëŠ¥<br>
  â¡ï¸ ```Quarter```ì— ëŒ€í•œ ```Coin``` ì—´ê±°í˜• variantë¡œë¶€í„° ë‚´ë¶€ ì£¼ì— ëŒ€í•œ ê°’ì„ ì–»ì„ ìˆ˜ ìˆìŒ â£ï¸â£ï¸â£ï¸â£ï¸

### Option<T>ë¥¼ ì´ìš©í•˜ëŠ” ë§¤ì¹­
```Option<T>```ë¥¼ ì‚¬ìš©í•  ë•Œ ```Some``` ì¼€ì´ìŠ¤ë¡œë¶€í„° ë‚´ë¶€ì˜ ```T``` ê°’ì„ ì–»ì„ í•„ìš”ê°€ ìˆì—ˆìŒ.<br>
ê·¸ëŸ°ë° ìœ„ ì—´ê±°í˜•ê³¼ ê°™ì´ ```match```ë¥¼ ì´ìš©í•˜ì—¬ ```Option<T>```ë¥¼ ë‹¤ë£° ìˆ˜ ìˆìŒ.
<br>

**```Option<i32>```ë¥¼ íŒŒë¼ë¯¸í„°ë¡œ ë°›ì•„ì„œ ë‚´ë¶€ì— ê°’ì´ ìˆìœ¼ë©´ ê·¸ ê°’ì— 1ì„ ë”í•˜ê³ , ì—†ìœ¼ë©´ ```None``` ê°’ì„ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ì˜ ì½”ë“œë¥¼ ì§œë³´ì!**
```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
```
<details>
<summary>ì¶œë ¥ë¬¸ ì¶”ê°€í•œ ì½”ë“œ</summary>
<div markdown="1">
    
```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

fn main() {
    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);

    println!("five: {:?}", five);  // added
    println!("six: {:?}", six);  // added
    println!("none: {:?}", none);  // added
}
```
</details>

#### Some(T) ë§¤ì¹­ í•˜ê¸°
* ```plus_one(five)``` í˜¸ì¶œë  ë•Œ, ```plus_one``` ë³¸ì²´ ë‚´ì˜ ```x```ëŠ” ```Some(5)```ë¥¼ ê°€ì§€ê²Œ ë¨.<br>
  ì´í›„ ìˆœì„œëŒ€ë¡œ, ê°ê° ë§¤ì¹˜ ê°ˆë˜ì™€ ì´ ê°’ì„ ë¹„êµí•¨.
  ```rust
  None => None,
  ```
  â¡ï¸ ë”± ë´ë„ ì•„ë‹ˆë‹ˆê¹Œ ë„˜ì–´ê°€.<br><br>
  ```rust
  Some(i) => Some(i + 1),
  ```
  â¡ï¸ ```Some(5)```ë‘ ```Some(i)```ë‘ ìƒê¸´ ê²Œ ë¹„ìŠ·í•¨ (== ë™ì¼í•œ variantë¥¼ ê°€ì§€ê³  ìˆìŒ)â—<br>
  â¡ï¸ ```Some``` ë‚´ë¶€ì˜ ê°’ì´ ```i```ì— ë°”ì¸ë“œ ë˜ë¯€ë¡œ ```i```ëŠ” ê°’ ```5```ë¥¼ ê°€ì§.<br>
  ğŸ¤“ ê·¸ ë‹¤ìŒì— ë§¤ì¹˜ ê°ˆë˜ ë‚´ ì½”ë“œ```Some(i + 1)``` ì‹¤í–‰ë¨<br><br>
  ğŸ’— ìµœì¢…ì ìœ¼ë¡œ ```i```ì— 6ì´ ë‹´ê¸´ ìƒˆë¡œìš´ ```Some``` ê°’ì´ ìƒì„±ë¨â—â—

<br>

#### None ë§¤ì¹­ í•˜ê¸°
* ```x```ê°€ ```None```ì¼ ë•Œì˜ ```plus_one``` í˜¸ì¶œí•´ë³´ê¸°
* ```match``` ì•ˆìœ¼ë¡œ ë“¤ì–´ì™€ ìˆœì„œëŒ€ë¡œ ë¹„êµí•  ê²ƒì„
  ```rust
  None => None,
  ```
  â¡ï¸ ê·¼ë°? Noneì´ë‘ ë§¤ì¹˜ê°€ ë¨.<br>
  â¡ï¸ ë”í•  ê±° ì—†ìœ¼ë‹ˆê¹Œ í”„ë¡œê·¸ë¨ ë©ˆì¶”ê³  ì½”ë“œ ë‚´ìš© ```None```ê°’ ë°˜í™˜<br><br>
  â• ë§¤ì¹­ë˜ì—ˆìœ¼ë‹ˆ ë‹¤ë¥¸ ê±°ë‘ ë¹„êµí•  í•„ìš” âŒ

<br>

### ```match```ê´€ì  í™•ì¥
ğŸ›ë²„ê·¸ğŸë‚˜ëŠ” ì½”ë“œ
```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        Some(i) => Some(i + 1),
    }
}
```
* ```None``` ì¼€ì´ìŠ¤ë¥¼ ë‹¤ë£¨ì§€ ì•Šì•˜ê¸° ë•Œë¬¸ì„.
* í¸ì§‘ê¸°ë¶€í„° ì—„ì²­ë‚œ ì½”ë©˜íŠ¸ë¥¼ ë³¼ ìˆ˜ ìˆìŒ â—â— ì •ë§ ì¹œì ˆí•¨ ^^b<br>
  lvimì˜ íŠ¹ì„±ì¸ì§„ ëª¨ë¥´ê² ìœ¼ë‚˜...<br>
  <img src="https://github.com/redzzzi/Rust23summer/assets/127263392/31e1297a-01c0-4ff1-adec-64604cfbc955" width="500px"><br><br>
  ë¦¬ëˆ…ìŠ¤ì—ì„œë„...<br>
  <img src="https://github.com/redzzzi/Rust23summer/assets/127263392/d08df388-a80c-401d-b9ac-031567a66fd9" width="500px"><br><br>
  ğŸ¤“ ëª¨ë“  ë°©ë©´ì—ì„œ ```None``` ì¼€ì´ìŠ¤ë¥¼ ë‹¤ë£¨ë¼ê³  ì•Œë ¤ì£¼ê³  ìˆë‹¤ â—<br><br>
* íŠ¹íˆ ```Option<T>```ì˜ ê²½ìš°, Nullì¼ì§€ë„ ëª¨ë¥¼ ê°’ì„ ê°€ì§€ê³  ìˆìŒì„ ê°€ì •í•˜ì—¬ ì‹¤ìˆ˜ë¥¼ ë°©ì§€í•´ì¤Œ

<br>

### _ ë³€ê²½ì(placeholder)
ëª¨ë“  ê°€ëŠ¥í•œ ê°’ì„ ë‚˜ì—´í•˜ê³  ì‹¶ì§€ ì•Šì€ ê²½ìš°ì— ì‚¬ìš©.<br><br>
```rust
let some_u8_value = 0u8;
match some_u8_value {
    1 => println!("one"),
    3 => println!("three"),
    5 => println!("five"),
    7 => println!("seven"),
    _ => (),
}
```
* 1, 3, 5, 7ì— ëŒ€í•´ì„œë§Œ ì¢€ íŠ¹ë³„í•˜ê²Œ ì½”ë“œ ì§œê³  ë‚˜ë¨¸ì§€ëŠ” ë”±íˆ ë­ ì•ˆí•˜ê³  ì‹¶ì„ ë•Œ.
* ```_``` íŒ¨í„´ì€ ì´ì „ì— ëª…ì‹œë˜ì§€ ì•Šì€ ì–´ë– í•œ ê°’ê³¼ë„ ë‹¤ ë§¤ì¹­ë¨.
* ```()```ëŠ” ìœ ë‹› ê°’ìœ¼ë¡œ, ```_``` ì¼€ì´ìŠ¤ì—ì„œ ì–´ë–¤ ì¼ë„ ë°œìƒ âŒ
* ìœ„ ì½”ë“œë¥¼ ì–´ë–»ê²Œ ì˜ ìˆ˜ì •í•´ì„œ ì¶œë ¥ë˜ëŠ” ì½”ë“œë¡œ ë§Œë“ ë‹¤ì³ë„, 0ì€ ```_``` íŒ¨í„´ê³¼ ë§¤ì¹­ë˜ì–´ ì•„ë¬´ ì¼ë„ ì¼ì–´ë‚˜ì§€ ì•Šì„ ê²ƒì„. ~~ì•„ë§ˆë„..?~~
<br><br>

## 3. if letì„ ì‚¬ìš©í•œ ê°„ê²°í•œ íë¦„ ì œì–´
### ```if let``` ë¬¸ë²•
: ```if```ì™€ ```let``` ì¡°í•©. í•˜ë‚˜ì˜ íŒ¨í„´ë§Œ ë§¤ì¹­ì‹œí‚¤ê³  ë‚˜ë¨¸ì§€ ê²½ìš°ëŠ” ë¬´ì‹œí•˜ëŠ” ê°’ì„ ë‹¤ë£¨ëŠ” ë°©ë²• â—
<br>
#### ```Option<u8>``` ê°’ì„ ë§¤ì¹­í•˜ë©´ì„œë„ ê°’ì´ 3ì¼ ë•Œë§Œ ì½”ë“œë¥¼ ì‹¤í–‰í•˜ëŠ” í”„ë¡œê·¸ë¨
<br>

```rust
let some_u8_value = Some(0u8);
match some_u8_value {
    Some(3) => println!("three"),
    _ => (),
}
```

* ```match``` í‘œí˜„ì‹ì—ì„œ íƒ€ ```Some<u8>``` ê°’ ë˜ëŠ” ```None``` ê°’ì¸ ê²½ìš°ë¥¼ ì•„ìš°ë¥´ê¸° ìœ„í•´ ```_ => ()```ë¥¼ ì‚¬ìš©í•˜ì§€ë§Œ,<br>
  [**ë³´ì¼ëŸ¬ í”Œë ˆì´íŠ¸ ì½”ë“œ**](https://en.wikipedia.org/wiki/Boilerplate_code) ì¶”ê°€ë¨<br><br>
  â¡ï¸ íŒ¨í„´ ë§¤ì¹­ì„ í•˜ë ¤ëŠ” ê²½ìš°ë§ˆë‹¤ ë™ì¼í•œ ë¹ˆ ë¸”ë¡ì„ ì¶”ê°€í•´ì•¼í•˜ëŠ” ë²ˆê±°ë¡œì›€
  <details>
  <summary>Boilerplate code meaning on <i>wikipedia</i></summary>
  <div markdown="1">

  <pre>
  Boilerplate code meaning on <i>wikipedia</i><br>
      <i>In computer programming,<br>
          boilerplate code, or simply boilerplate, are sections of code<br>
          <b>that are repeated in multiple places with little to no variation.</b></i>
  </pre>
  </details>

#### í•˜ì§€ë§Œ ```if let``` ë¬¸ë²•ì„ ì“´ë‹¤ë©´?
ìœ„ì™€ ë™ì¼í•˜ê²Œ ë™ì‘í•˜ëŠ” ì½”ë“œ

```rust
if let Some(3) = some_u8_value {  // â† ìœ„ ì½”ë“œì˜ match ì²« ë²ˆì§¸ ê°ˆë˜ì™€ ë™ì¼
    println!("three");
}
```
* ì •ë§ ê°„ë‹¨í•¨ ^^b
* ```=```ë¡œ êµ¬ë¶„ëœ íŒ¨í„´ê³¼ í‘œí˜„ì‹ ì…ë ¥ë°›ìŒ
* ë‹¨ì : ```match```ì—ì„œ ì§„í–‰ëë˜ ì „ìˆ˜ ì¡°ì‚¬ë¥¼ ë°›ì„ ìˆ˜ ì—†ìŒ (í‹€ë¦° ë¶€ë¶„ í•˜ë‚˜í•˜ë‚˜ ì•Œë ¤ì£¼ëŠ” ê±°)
* ```if let```ì€, íŠ¹ì • íŒ¨í„´ ë§¤ì¹­ ì¼€ì´ìŠ¤ ì œì™¸ ë‹¤ë¥¸ ê°’ë“¤ì— ëŒ€í•´ ë¬´ì‹œí•˜ëŠ” ```match``` ë¬¸ì„ ìœ„í•œ ë¬¸ë²•ì  ì„¤íƒ•*syntax sugar*[^id]ë¼ê³  ìƒê°í•  ìˆ˜ ìˆìŒ ã…

#### ```if let```ê³¼ í•¨ê»˜ ë‚˜ì˜¤ëŠ” ```else```
```else``` ë’¤ì— ë‚˜ì˜¤ëŠ” ì½”ë“œ ë¸”ë¡ == ```match``` í‘œí˜„ì‹ì—ì„œ ```_``` ì¼€ì´ìŠ¤ ë’¤ì— ë‚˜ì˜¤ëŠ” ì½”ë“œ ë¸”ë¡<br><br>
ì•„ê¹Œ ë™ì „ ì˜ˆì œì—ì„œ íŒŒìƒëœ ë¬¸ì œ â¬‡ï¸<br>
#### ëª¨ë“  ë™ì „ì„ ì„¸ë©´ì„œ ë™ì‹œì— ì¿¼í„° ë™ì „ì¸ ê²½ìš°ë¥¼ ì•Œë ¤ì£¼ê³  ì‹¶ì„ ë•Œì˜ í‘œí˜„ì‹.
```if let```ê³¼ ```else``` í‘œí˜„ì‹ ì‚¬ìš©
```rust
let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!("State quarter from {:?}!", state);
} else {
    count += 1;
}
```

<details>
<summary><code>match</code> ë¬¸ ì‚¬ìš©</summary>
<div markdown="1">

```rust
let mut count = 0;
match coin {
    Coin::Quarter(state) => println!("State quarter from {:?}!", state),
    _ => count += 1,
}
```
</details>
<br><br>

#### ì§œê³  ì‹¶ì€ ì½”ë“œê°€ ìˆëŠ”ë° ë„ˆë¬´ ì¡°ì¡í•œ ê²ƒ ê°™ë‹¤ â‰ï¸ â¡ï¸ ```if let```ìœ¼ë¡œ ëŸ° â—
<br><br><br>


[^id]: ì½”ë“œë¥¼ ë” ì§ê´€ì ìœ¼ë¡œ ë§Œë“œëŠ” ë¬¸ë²•ì  ë‹¨ì¶• í‘œí˜„. ì–¸ì–´ì˜ êµ¬ë¬¸ì„ ë‹¨ìˆœí™”í•˜ê±°ë‚˜ í‘œí˜„ë ¥ì„ í–¥ìƒì‹œí‚¤ëŠ” ì—­í• ì„ í•¨.
