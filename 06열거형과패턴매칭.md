# ğŸ“œ 06 Enums and Pattern Matching
[ì—´ê±°í˜• ì •ì˜](#1-ì—´ê±°í˜•-ì •ì˜í•˜ê¸°)&emsp;[match](#2-match-íë¦„-ì œì–´-ì—°ì‚°ì)&emsp;[if let íë¦„ ì œì–´](#3-if-letì„-ì‚¬ìš©í•œ-ê°„ê²°í•œ-íë¦„-ì œì–´)
<br><br>

## 1. ì—´ê±°í˜• ì •ì˜í•˜ê¸°
ì—´ê±°í˜•ì˜ variants
```rust
enum IpAddrKind {
    V4,
    V6,
}
```
* ë‚˜ì—´ *enumerate* == ì—´ê±°
<br><br>

### ì—´ê±°í˜• ê°’
```IpAddrKind```ì˜ variantsì— ëŒ€í•œ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
```rust
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
```
<br>

```IpAddrKind``` íƒ€ì…ì„ ì¸ìë¡œ ë°›ëŠ” í•¨ìˆ˜ ì •ì˜
```rust
fn route(ip_type: IpAddrKind) { }
```
<br>

variant ì¤‘ í•˜ë‚˜ë¥¼ ì‚¬ìš©í•´ í•¨ìˆ˜ í˜¸ì¶œ
```rust
route(IpAddrKind::V4);
route(IpAddrKind::V6);
```
<br>
<details>
<summary>êµ¬ì¡°ì²´ë¡œ í•´ê²°</summary>
<div markdown="1">
  
```rust
enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from("127.0.0.1"),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from("::1"),
};
```
* ë‘ ê°œì˜ í•„ë“œ(kind, address)ë¥¼ ê°–ëŠ” ```IPAddr``` ì •ì˜
</details>
<details>
<summary>ì—´ê±°í˜•ìœ¼ë¡œ í•´ê²°</summary>
<div markdown="1">

```rust
enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));

let loopback = IpAddr::V6(String::from("::1"));
```
* ì—´ê±°í˜• variantì— ì§ì ‘ ë°ì´í„° ë¶™ì„
* ë˜í•œ ```V4``` ì£¼ì†Œì—ëŠ” 4ê°œì˜ ```u8``` ê°’ì„ ì €ì¥í•˜ê³ , ```V6``` ì£¼ì†Œì—ëŠ” í•˜ë‚˜ì˜ ```String``` ê°’ìœ¼ë¡œ í‘œí˜„í•˜ëŠ” ê²ƒ ê°€ëŠ¥â— (êµ¬ì¡°ì²´ëŠ” ë¶ˆê°€)
  ```rust
  enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
  }

  let home = IpAddr::V4(127, 0, 0, 1);
  
  let loopback = IpAddr::V6(String::from("::1"));
  ```

</details>
<br>

[IP ì£¼ì†Œ ê´€ë ¨ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì •ì˜](https://doc.rust-lang.org/std/net/enum.IpAddr.html)
```rust
struct Ipv4Addr {
    // details elided
}

struct Ipv6Addr {
    // details elided
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
```
<br>
<details>
<summary>ì—´ê±°í˜•ì˜ ë‹¤ë¥¸ ì˜ˆì œ</summary>
<div markdown="1">

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```
* ë‹¤ë¥¸ ë°ì´í„° íƒ€ì…ì„ ê°–ëŠ” ë„¤ ê°œì˜ variants
    * ```Quit```: ì—°ê´€ ë°ì´í„° âŒ
    * ```Move```: ìµëª… êµ¬ì¡°ì²´ í¬í•¨
    * ```Write```: í•˜ë‚˜ì˜ ```String``` í¬í•¨
    * ```ChangeColor```: ì„¸ ê°œì˜ ```i32``` í¬í•¨
* ```struct``` í‚¤ì›Œë“œ ë¯¸ì‚¬ìš©
* ëª¨ë“  variantsê°€ ```Message``` íƒ€ì…ìœ¼ë¡œ ê·¸ë£¹í™”
<br>
ìœ„ì™€ ë™ì¼í•œ variantsì˜ ë°ì´í„°ë¥¼ í¬í•¨í•˜ëŠ” ì½”ë“œ

```rust
struct QuitMessage; // ìœ ë‹› êµ¬ì¡°ì²´
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // íŠœí”Œ êµ¬ì¡°ì²´
struct ChangeColorMessage(i32, i32, i32); // íŠœí”Œ êµ¬ì¡°ì²´
```
* ë©”ì‹œì§€ ì¤‘ ì–´ë–¤ í•œ ê°€ì§€ë¥¼ ì¸ìë¡œ ë°›ëŠ” í•¨ìˆ˜ ì •ì˜ ê°€ëŠ¥ (âˆµ ```Message``` ì—´ê±°í˜•ì€ í•˜ë‚˜ì˜ íƒ€ì…)

</details>
<br>

### ë©”ì†Œë“œ ì •ì˜ê°€ ê°€ëŠ¥í•œ ì—´ê±°í˜•
```rust
impl Message {
    fn call(&self) {
        // ë©”ì†Œë“œ ë‚´ìš©ì€ ì—¬ê¸° ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    }
}

let m = Message::Write(String::from("hello"));
m.call();
```
* ì—´ê±°í˜• ê°’ ê°€ì ¸ì˜¤ê¸° ìœ„í•´ ë©”ì†Œë“œ ë‚´ì—ì„œ ```self``` ì‚¬ìš©
* ```m.call()``` ì‹¤í–‰ â¡ï¸ ```m```ì˜ ê°’ì´ ```Message::Write(String::from("hello"))```ì—ì„œ ```call``` ë©”ì†Œë“œ ë‚´ì—ì„œ ```self```ê°€ ë¨.
<br>

### Options ì—´ê±°í˜• ê·¸ë¦¬ê³  ì´ê²ƒì´ Nullê°’ë³´ë‹¤ ì¢‹ì€ ì  
* ```Option``` íƒ€ì…ì€ *ê°’ì´ ìˆê±°ë‚˜ ì—†ì„ ìˆ˜ë„ ìˆëŠ”* ì•„ì£¼ í”í•œ ìƒí™©ì„ ë‚˜íƒ€ë‚´ê¸° ë•Œë¬¸ì—, íƒ€ì… ì‹œìŠ¤í…œì˜ ê´€ì ì—ì„œ **ì»´íŒŒì¼ëŸ¬ê°€ ë°œìƒí•  ìˆ˜ ìˆëŠ” ëª¨ë“  ê²½ìš°ë¥¼ ì²˜ë¦¬í–ˆëŠ”ì§€** ì²´í¬í•  ìˆ˜ ìˆìŒâ—
* ëŸ¬ìŠ¤íŠ¸ì—ëŠ” null íŠ¹ì„±ì´ ì—†ìŒ
<br>

[Option<T> í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì •ì˜](https://doc.rust-lang.org/std/option/enum.Option.html)
```rust
enum Option<T> {
    Some(T),
    None,
}
```
* ```Option<T>``` ì—´ê±°í˜•ì€ ê¸°ë³¸ì ìœ¼ë¡œ í¬í•¨ë¨ â†’ ëª…ì‹œ ì•ˆí•˜ê³ ë„ ë°”ë¡œ ì‚¬ìš© ê°€ëŠ¥
    * ```Option::```ì„ ì•ì— ë¶™ì´ì§€ ì•Šê³  ```Some```ê³¼ ```None```ì˜ variants ì‚¬ìš©
<br>

**\<T>ì˜ ê¸°ëŠ¥**
* ```Option``` ì—´ê±°í˜•ì˜ ```Some``` variantsê°€ ì–´ë–¤ íƒ€ì…ì˜ ë°ì´í„°ë¼ë„ ê°€ì§ˆ ìˆ˜ ìˆê²Œ í•¨
* ëŸ¬ìŠ¤íŠ¸ ë¬¸ë²•
* [ì œë„ˆë¦­ íƒ€ì…](https://rinthel.github.io/rust-lang-book-ko/ch10-01-syntax.html) íŒŒë¼ë¯¸í„°
<details>
<summary>ìˆ«ì íƒ€ì…ê³¼ ë¬¸ìì—´ íƒ€ì… ê°–ëŠ” <code>Option</code>ê°’ì— ëŒ€í•œ ì˜ˆ</summary>
<div markdown="1">

```rust
let some_number = Some(5);
let some_string = Some("a string");

let absent_number: Option<i32> = None;
```
* ```Some``` ê°’ ì–»ê²Œ ë˜ë©´, 1ï¸âƒ£ ê°’ì´ ìˆìŒ 2ï¸âƒ£ ```Some```ì´ ê°–ê³  ìˆëŠ” ê°’ì— ëŒ€í•´ ì•Œ ìˆ˜ ìˆìŒ
* ```None```ì€ nullì˜ ì˜ë¯¸ë¥¼ ê°€ì§€ê²Œ ë˜ì–´ ìœ íš¨í•˜ì§€ ì•ŠìŒ
</details>

#### ê·¸ë˜ì„œ ì´ê²Œ nullì¸ ê²ƒë³´ë‹¤ ì¢‹ì€ ì´ìœ 
```rust
let x: i8 = 5;
let y: Option<i8> = Some(5);

let sum = x + y;
```
ì—ëŸ¬ ë©”ì‹œì§€
<pre>
error[E0277]: the trait bound `i8: std::ops::Add<std::option::Option<i8>>` is
not satisfied
 -->
  |
7 | let sum = x + y;
  |           ^^^^^
  |
</pre>
* ì¼ë‹¨ ìœ„ ì½”ë“œëŠ” ```Option<i8>```ì— ```i8```ì„ ë”í•˜ë ¤ê³  í•´ì„œ ì»´íŒŒì¼ ë˜ì§€ ì•ŠìŒ<br>
  â¡ï¸ ì»´íŒŒì¼ëŸ¬ì—ì„œ ìœ„ì˜ ```Option<i8>```ì²˜ëŸ¼ ìœ íš¨í•˜ê²Œ ì‚¬ìš©í•˜ì§€ ëª»í•˜ê²Œ í•¨
* ```Option<T>```ì™€ ```<T>```(ğŸ…ì–´ë–¤ íƒ€ì…ì´ë“  ë  ìˆ˜ ìˆìŒ)ëŠ” ë‹¤ë¥¸ íƒ€ì…ì„
* ìœ„ ì½”ë“œì—ì„œëŠ” ì—ëŸ¬ê°€ ëœ¨ì§€ë§Œ, **ëŸ¬ìŠ¤íŠ¸ì—ì„œ ```i8```ê³¼ê°™ì€ íƒ€ì…ì˜ ê°’ì„ ê°€ì§ˆ ë•Œ nullì¸ì§€ í™•ì¸í•  í•„ìš” ì—†ì´ ì‚¬ìš© ê°€ëŠ¥**
* ìœ„ê°™ì€ ê²½ìš°ì—ì„œëŠ” ê°’ì˜ ì¡´ì¬ ì—¬ë¶€ì— ëŒ€í•´ ìƒê°í•´ë´ì•¼í•¨
* ```T``` ëŒ€í•œ ì—°ì‚° ìˆ˜í–‰ ì „ ```Option<T>```ë¥¼ ```T```ë¡œ ë³€í™˜í•´ì•¼ í•¨
* nullì¼ ìˆ˜ ìˆëŠ” ê°’ì„ ì‚¬ìš©í•˜ê¸° ìœ„í•´ ëª…ì‹œì ìœ¼ë¡œ ê°’ì˜ íƒ€ì…ì„ ```Option<T>```ë¡œ ë§Œë“¤ê¸°
<br>

## 2. match íë¦„ ì œì–´ ì—°ì‚°ì

### ```match```
* ê°•ë ¥í•œ íë¦„ ì œì–´ ì—°ì‚°ì
* ì¼ë ¨ì˜ íŒ¨í„´ì— ëŒ€í•´, ì–´ë–¤ ê°’ì„ ë¹„êµí•˜ê³  ì–´ë–¤ íŒ¨í„´ì— ë§¤ì¹˜ë˜ì—ˆëŠ”ì§€ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì½”ë“œ ìˆ˜í–‰ ë„ì›€
* íŒ¨í„´ì„ êµ¬ì„±í•˜ëŠ” ê²ƒì—ëŠ” ë¦¬í„°ëŸ´ ê°’, ë³€ìˆ˜ëª…, ì™€ì¼ë“œ ì¹´ë“œ ë“±ì´ ìˆìŒ
  <details>
  <summary>ìì„¸íˆ</summary>
  <div markdown="1">

  ```ì½”ë“œ ì¶œì²˜: chatGPT```
  1. ë¦¬í„°ëŸ´ ê°’: íŠ¹ì •í•œ ê°’ ìì²´
     * ìˆ«ì, ë¬¸ìì—´, ë¶ˆë¦¬ì–¸ ê°’, etc.
     ```rust
     let number = 42;
     match number {
         0 => println!("The number is zero"),
         1 => println!("The number is one"),
     }
     ```
  2. ë³€ìˆ˜ëª…
     * íŒ¨í„´ ë§¤ì¹­ ì‹œ ê°’ì„ ë°”ì¸ë”© í•˜ëŠ” ë° ì‚¬ìš©ë¨.
     * ë§¤ì¹­í•˜ëŠ” ê°’ì´ í•´ë‹¹ ë³€ìˆ˜ì— í• ë‹¹ë¨. â†’ ê°’ ì¶”ì¶œ, í™œìš©
     ```rust
     let point = (3, 4);
     match point {
         (x, y) => println!("The point is at coordinates: ({}, {})", x, y),
     }
     ```
  3. ì™€ì¼ë“œì¹´ë“œ: ì–´ë–¤ ê°’ì—ë„ ë§¤ì¹˜ë˜ëŠ” íŠ¹ë³„í•œ íŒ¨í„´.
     * ```_``` ê¸°í˜¸ë¡œ í‘œì‹œ.
     * íŠ¹ì • ê°’ì— ê´€ì‹¬ì´ ì—†ê±°ë‚˜ ì‚¬ìš©í•˜ì§€ ì•Šì„ ë•Œ ìœ ìš©í•¨b.
     ```rust
     let number = 42;
     match number {
         _ => println!("I don't care about the value"),
     }
     ```
  </details>
<br>

### ğŸª™ë™ì „ğŸª™ ì˜ˆì œ
ë¯¸êµ­ ë™ì „ì„ ì…ë ¥ë°›ì•„, ì–´ë–¤ ë™ì „ì¸ì§€ì™€ ì„¼íŠ¸ë¡œ ë°˜í™˜í•˜ê¸°
```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u32 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```
* ì—´ê±°í˜•ê³¼ ì—´ê±°í˜• variantë¥¼ íŒ¨í„´ìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” ```match``` í‘œí˜„ì‹ì„
* ```match``` í‚¤ì›Œë“œ ë’¤ ```coin``` íƒ€ì…ì€ ```Coin``` ì—´ê±°í˜•ì„
* ```match```ì˜ ê°ˆë˜ë“¤
    * í•˜ë‚˜ì˜ ê°ˆë˜ = ```íŒ¨í„´``` + ```ì½”ë“œ```
    * ê° ê°ˆë˜ëŠ” ê·¸ ë‹¤ìŒ ê°ˆë˜ì™€ ì‰¼í‘œë¡œ êµ¬ë¶„
    * ```Coin::Penny => 1,```ì—ì„œ,<br>
      ```Coin::Penny```ì˜ íŒ¨í„´ì„ ê°€ì§€ë©° ```=>``` ì—°ì‚°ìë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì‹¤í–‰ë˜ëŠ” ì½”ë“œ(ê°’ ```1```)ë¥¼ ì•Œ ìˆ˜ ìˆìŒ.
    * ```=>```: íŒ¨í„´ê³¼ ì‹¤í–‰ë˜ëŠ” ì½”ë“œë¥¼ êµ¬ë¶„í•´ì£¼ëŠ” ì—°ì‚°ì
* ```match``` í‘œí˜„ì‹ ì‹¤í–‰ ì‹œ, ê²°ê³¼ê°’ì„ ê° ê°ˆë˜ì˜ íŒ¨í„´ê³¼ ìˆœì°¨ ë¹„êµ.<br>
  ğŸ¤“ **ì–´ë–¤ íŒ¨í„´ì´ ê·¸ ê°’ì´ë‘ ë§¤ì¹˜ëœë‹¤** â¡ï¸ ê·¸ íŒ¨í„´ê³¼ ì—°ê´€ëœ ì½”ë“œ ì‹¤í–‰<br>
  ğŸ¤“ **ë§¤ì¹˜ë˜ì§€ ì•ŠëŠ”ë‹¤** â¡ï¸ ë‹¤ìŒ ê°ˆë˜ë¡œ ê³„ì† ì‹¤í–‰
* ì‹¤í–‰í•˜ê³ ì í•˜ëŠ” ì½”ë“œê°€ ì—¬ëŸ¬ ì¤„ì´ë¼ë©´ ì¤‘ê´„í˜¸ ì‚¬ìš©.<br>
  ì˜ˆì‹œ
  ```rust
  fn value_in_cents(coin: Coin) -> u32 {
      match coin {
          Coin::Penny => { // <- ì¤‘ê´„í˜¸ ì‹œì‘
              println!("Lucky penny!");
              1
          },  // <- ì¤‘ê´„í˜¸ ëë
          Coin::Nickel => 5,
          Coin::Dime => 10,
          Coin::Quarter => 25,
      }
  }
  ```
<br>

### ê°’ë“¤ì„ ë°”ì¸ë”©í•˜ëŠ” íŒ¨í„´
* ë§¤ì¹˜ ê°ˆë˜ì˜ ê¸°ëŠ¥ â•: íŒ¨í„´ê³¼ ë§¤ì¹˜ëœ ê°’ë“¤ì˜ ë¶€ë¶„ ë°”ì¸ë”©(ë³€ìˆ˜ì— ê°’ í• ë‹¹í•˜ê¸°) ê°€ëŠ¥
<br>

*1999~2008ë…„, ë¯¸êµ­ì€ ê° 50ê°œ ì£¼ë§ˆë‹¤ í•œìª½ ë©´ì˜ ë””ìì¸ì´ ë‹¤ë¥¸ **ì¿¼í„° ë™ì „** ì£¼ì¡°*<br>

â¡ï¸ ```Quarter``` variant ë‚´ì— ```UsState``` ê°’ì„ í¬í•¨í•˜ë„ë¡ ì—´ê±°í˜•```enum``` ë³€ê²½í•¨ìœ¼ë¡œì¨ ì¶”ê°€í•  ìˆ˜ ìˆìŒâ—

```rust
#[derive(Debug)] // So we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // ... etc
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
```

* ìœ„ì—ì„œ ì–¸ê¸‰ëœ ë°”ì™€ ê°™ì´, ```Coin``` ì—´ê±°í˜•ì—ì„œ ```Quarter``` variantê°€ ```UsState```ê°’ ë˜í•œ ë“¤ê³  ìˆìŒ
<br>

ì¿¼í„° ë™ì „ë§ˆë‹¤ ì£¼ ì´ë¦„ì„ ì¶œë ¥í•˜ë ¤ë©´? â¡ï¸ ```state``` ë³€ìˆ˜ ì¶”ê°€í•´ì£¼ë©´ ë¨<br>

ì•„ë˜ ì½”ë“œë¥¼ ìœ„ ì½”ë“œì— ì¶”ê°€
```rust
fn value_in_cents(coin: Coin) -> u32 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        },
    }
}
```
* ```value_in_cents(Coin::Quarter(UsState::Alaska))```ì„ í˜¸ì¶œí–ˆì„ ë•Œ, ```coin```ì€ ```Coin::Quarter(UsState::Alaska)```ì— í•´ë‹¹.
* ê°ê°ì˜ ë§¤ì¹˜ ê°ˆë˜ì™€ í•´ë‹¹ ê°’ì„ ë¹„êµí•˜ì—¬ ```Coin::Quarter(state)```ì— ë„ë‹¬í•  ë•Œê¹Œì§€ ë§¤ì¹˜ âŒ
* ```state```ì— ëŒ€í•œ ë°”ì¸ë”© ê°’ == ```UsState::Alaska```<br>
  â¡ï¸ í•´ë‹¹ ë°”ì¸ë”©ì„ ```println!``` í‘œí˜„ì‹ ë‚´ ì‚¬ìš© ê°€ëŠ¥<br>
  â¡ï¸ ```Quarter```ì— ëŒ€í•œ ```Coin``` ì—´ê±°í˜• variantë¡œë¶€í„° ë‚´ë¶€ ì£¼ì— ëŒ€í•œ ê°’ì„ ì–»ì„ ìˆ˜ ìˆìŒ â£ï¸â£ï¸â£ï¸â£ï¸

### Option<T>ë¥¼ ì´ìš©í•˜ëŠ” ë§¤ì¹­
```Option<T>```ë¥¼ ì‚¬ìš©í•  ë•Œ ```Some``` ì¼€ì´ìŠ¤ë¡œë¶€í„° ë‚´ë¶€ì˜ ```T``` ê°’ì„ ì–»ì„ í•„ìš”ê°€ ìˆì—ˆìŒ.<br>
ê·¸ëŸ°ë° ìœ„ ì—´ê±°í˜•ê³¼ ê°™ì´ ```match```ë¥¼ ì´ìš©í•˜ì—¬ ```Option<T>```ë¥¼ ë‹¤ë£° ìˆ˜ ìˆìŒ.
<br>

**```Option<i32>```ë¥¼ íŒŒë¼ë¯¸í„°ë¡œ ë°›ì•„ì„œ ë‚´ë¶€ì— ê°’ì´ ìˆìœ¼ë©´ ê·¸ ê°’ì— 1ì„ ë”í•˜ê³ , ì—†ìœ¼ë©´ ```None``` ê°’ì„ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ì˜ ì½”ë“œë¥¼ ì§œë³´ì!**
```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
```
<details>
<summary>ì¶œë ¥ë¬¸ ì¶”ê°€í•œ ì½”ë“œ</summary>
<div markdown="1">
    
```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

fn main() {
    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);

    println!("five: {:?}", five);  // added
    println!("six: {:?}", six);  // added
    println!("none: {:?}", none);  // added
}
```
</details>

#### Some(T) ë§¤ì¹­ í•˜ê¸°
* ```plus_one(five)``` í˜¸ì¶œë  ë•Œ, ```plus_one``` ë³¸ì²´ ë‚´ì˜ ```x```ëŠ” ```Some(5)```ë¥¼ ê°€ì§€ê²Œ ë¨.<br>
  ì´í›„ ìˆœì„œëŒ€ë¡œ, ê°ê° ë§¤ì¹˜ ê°ˆë˜ì™€ ì´ ê°’ì„ ë¹„êµí•¨.
  ```rust
  None => None,
  ```
  â¡ï¸ ë”± ë´ë„ ì•„ë‹ˆë‹ˆê¹Œ ë„˜ì–´ê°€.<br><br>
  ```rust
  Some(i) => Some(i + 1),
  ```
  â¡ï¸ ```Some(5)```ë‘ ```Some(i)```ë‘ ìƒê¸´ ê²Œ ë¹„ìŠ·í•¨ (== ë™ì¼í•œ variantë¥¼ ê°€ì§€ê³  ìˆìŒ)â—<br>
  â¡ï¸ ```Some``` ë‚´ë¶€ì˜ ê°’ì´ ```i```ì— ë°”ì¸ë“œ ë˜ë¯€ë¡œ ```i```ëŠ” ê°’ ```5```ë¥¼ ê°€ì§.<br>
  ğŸ¤“ ê·¸ ë‹¤ìŒì— ë§¤ì¹˜ ê°ˆë˜ ë‚´ ì½”ë“œ```Some(i + 1)``` ì‹¤í–‰ë¨<br><br>
  ğŸ’— ìµœì¢…ì ìœ¼ë¡œ ```i```ì— 6ì´ ë‹´ê¸´ ìƒˆë¡œìš´ ```Some``` ê°’ì´ ìƒì„±ë¨â—â—

<br>

### ë‹¤ë¥¸ ì¸¡ë©´ì—ì„œì˜ ```match```
<br>

### _ ë³€ê²½ì(placeholder)

<br><br>

## 3. if letì„ ì‚¬ìš©í•œ ê°„ê²°í•œ íë¦„ ì œì–´
