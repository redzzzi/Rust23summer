# 📜 Common Collections
* 러스트 표준라이브러리에는 *컬렉션*이라는 것이 있음. 여러 유용한 데이터 구조들이 포함되어 우리를 도와줌!
* 컬렉션이 가리키는 데이터들은 힙에 저장됨<br>
  → **데이터량**이 ☝️컴파일 타임에 결정되지 않아도 됨 ✌️프로그램이 실행될 때 늘어나거나 줄어들 수 있음<br><br><br>
[Vectors](#1-storing-lists-of-values-with-vectors)&emsp;[Strings](#2-storing-utf-8-encoded-text-with-strings)&emsp;[Hash Maps](#3-storing-keys-with-associated-values-in-hash-maps)
<br><br>

## 1. Storing Lists of Values with Vectors
### Ⅰ. ```Vec<T>```
* 단일 데이터 구조 안에 하나 이상의 값 저장
* 같은 타입의 값만을 저장
* 생성 예시
    * ```Vec::new``` 함수 호출
    <br>

    ```rust
    let v: Vec<i32> = Vec::new();
    // v 안의 Vec가 i32 타입의 요소 가짐
    ```
* 벡터에 값 대입 안한 경우, **타입 명시** 해줘야 함<br>
  (이때, 어떤 종류의 값도 저장 가능, 특정 타입 명시는 ```<>```를 통해 표시)
* 벡터에 값 대입 한 경우, 러스트가 저장 값의 타입을 대부분 유추 → 타입 명시 불필요

### Ⅱ. ```vec!``` 매크로
* **대입된 값을 저장**하고, **새로운 ```Vec```을 생성**함
* 아래의 경우, 값 1, 2, 3을 저장하고 해당 값의 타입 i32의 속성을 지닌 ```Vec<i32>```을 생성
  <br>

  ```rust
  let v = vec![1, 2, 3];
  ```
  
### Ⅲ. ```push``` 메소드
* 벡터에 값을 추가하여 갱신할 수 있음
* 사용 예시
  <br>

  ```rust
  let mut v = Vec::new();

  v.push(1);
  v.push(2);
  v.push(3);
  v.push(4);
  ```
    * 일단 변수를 가변화시키려면 ```mut``` 키워드 사용해야함
    * 집어넣는 숫자가 ```i32``` 타입이기 때문에 ```Vec<i32>```와같은 명시 불필요
  
### Ⅳ. 벡터 드롭
* 벡터 요소들이 스코프 밖으로 벗어나면 해제
  <br>

  ```rust
  {
  let v = vec!['안', '녕', '하', '세', '요'];  // 스코프 유효시되는 시작점
  }  // 스코프 밖으로 벗어나 해제
    * 벡터가 가지고 있던 값들이 제거됨
    * v에 재접근 불가
  ```

### Ⅴ. 벡터 요소 읽기
#### ⅰ. ```[]``` 메소드 *인덱스 문법*  
```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5];
    let first: &i32 = &v[0];

    println!("{:?}", first);
}
```
```rust
1
```
* ```&```와 ```[]```을 이용하여 참조자를 얻음

#### ⅱ. ```get``` 메소드
```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5];
    let second: Option<&i32> = v.get(1);

    println!("{:?}", second);
}
```
```rust
Some(2)  // Option<&T>
```
* ```get``` 함수에 인덱스를 파라미터로 넘겨 ```Option<&T>```을 얻음

#### ⅲ. 인덱스 범위를 초과하는 경우
<img src="https://github.com/redzzzi/Rust23summer/assets/127263392/3c3bcbc5-2e67-4fa1-bd6f-3404f47513e9" width="600px"><br>
* ```vec_index.rs``` 파일의 인덱스 문법에서 ```panic!``` 발생 (친절하게 설명해줌)
    * 인덱스 메소드는 벡터 범위 벗어났을 때 프로그램 중단시키고 싶다면 쓰기 좋은 방법임
* ```vec_get.rs``` 파일의 ```get``` 함수에서 패닉 없이 ```None``` 반환
    * 보통의 경우 사용하는 것 추천
    * ```Some(&element)``` 또는 ```None```에 대한 로직을 갖춰 다른 상황으로 이어지게 할 수 있음
 
#### ⅳ. 벡터 수정 시 고려해야할 빌림 문제
<pre>
<b>참조자 규칙 中</b><br>
같은 스코프 내에서 가변 참조자와 불변 참조자를 동시에 가질 수 없다
</pre>
```rust
let mut v = vec![1, 2, 3, 4, 5];           // 1
let first = &v[0];                         // 2
v.push(6);                                 // 3
println!("The first element is: {first}"); // 4
```
<details>
<summary>경고와 설명들</summary>
<div markdown="1">

```cargo run```<br>
<img src="https://github.com/redzzzi/Rust23summer/assets/127263392/5e4dd4dd-4ec1-4d22-9a91-8fd1b9e4d76d" width="600px">
<br><br>
```rustc --explain E0502```<br>
<img src="https://github.com/redzzzi/Rust23summer/assets/127263392/e7e1bc83-ac2f-40d9-8fd2-cde5a4c45394" width="600px">
<br><br>
➕ ```rustc --explain E0499```<br><br>
<i>어떤 변수에 대해서 동시에 두번 이상 가변 참조할 수 없음 (단, 불변 참조는 여러 번 가능)</i><br>
<img src="https://github.com/redzzzi/Rust23summer/assets/127263392/4f943394-b5a3-4022-8725-226a3b3692aa" width="600px">

</details>

* 두 번째 라인에서 ```immutable``` borrow, 세 번째 라인에서 ```mutable``` borrow
* 위 코드가 동작하는 방식<br><br>
  : ```push``` 메소드 사용할 때, 벡터가 메모리에서 값을 옆에 계속 배치하다보니 모든 요소가 들어갈 공간이 충분치 않다면 새 메모리를 할당하고 새 공간이 이전 요소를 복사해야(기존 메모리 공간 해제)할 상황이 생길 수 있음<br><br>
  : 이때 첫번째 요소 참조자가 할당 해제된 메모리를 가리키게 될 수 있음<br>
<pre>
  → 메모리 할당 및 복사 작업으로 인해 요소 위치가 변경될 수 있는 상황에는 벡터의 가변 참조를 가져오는 동안 다른 가변 참조를 가져올 수 없음<br>
  → 벡터 요소들이 유효한 메모리에 계속 존재할 수 있음
</pre>
  
### Ⅵ. ```for``` 루프를 사용한 벡터 값들에 대한 반복 처리
* 불변 참조자 얻어서 ```for``` 써서 어쩌구저쩌구 하면 됨<br>
<img src="https://github.com/redzzzi/Rust23summer/assets/127263392/18dde88e-8dab-4c27-ae94-3adcc50c6867" width="600px"><br>
* 요소들에 *더하기, 빼기 등의* 변형을 하려면??
  <br>

  ```rust
  fn main() {
      let mut v = vec![10, 20, 30];
      for i in &mut v {
          *i += 5;  
          println!("{}", i);
      }
  }
  ```
    * 가변 참조 생성
    * ```*i```라고 표기함으로써 실제 값에 접근하고 수정하는 것이 가능
    * 역참조 연산자 ```*```

### Ⅶ. 열거형으로 여러 타입 저장하기
* 벡터는 같은 타입의 값만 저장 가능 → 불편
* 같은 열거형 타입 내에서 **다른 타입들의 variant**를 설정할 수 있음!
* 사용 예시
  <br>

  ```rust
  fn main() {
      enum DifferentType {
          Int(i32),
          Float(f64),
          Text(String),
      }
  
      let cool = vec![
          DifferentType::Int(311),
          DifferentType::Float(3.12),
          DifferentType::Text(String::from("wow")),
      ];
  
      for i in cool {
          match i {
              DifferentType::Int(value)   => println!("Int: {}", value),
              DifferentType::Float(value) => println!("Float: {}", value),
              DifferentType::Text(value)  => println!("Text: {}", value),
          }
      }
  }
  ```
    * 벡터 내 저장될 타입을 알아야 하는 이유: 요소 저장 시 필요한 힙 [메모리](http://www.tcpschool.com/c/c_memory_structure) 용량 파악
    * 흐름 제어 연산자 [match](https://github.com/redzzzi/Rust23summer/blob/main/rustlang/06_%EC%97%B4%EA%B1%B0%ED%98%95%EA%B3%BC%ED%8C%A8%ED%84%B4%EB%A7%A4%EC%B9%AD.md#2-match-%ED%9D%90%EB%A6%84-%EC%A0%9C%EC%96%B4-%EC%97%B0%EC%82%B0%EC%9E%90)
<br>

## 2. Storing UTF-8 Encoded Text with Strings
<br>

## 3. Storing Keys with Associated Values in Hash Maps
<br>
