# 📜 05 Using Structs to Structure Related Data
[구조체 정의•생성](#1-구조체를-정의하고-생성하기)&emsp;[구조체 이용 예제](#2-구조체를-이용한-예제-프로그램)&emsp;[메소드 문법](#3-메소드-문법)
<br><br>

## 구조체가 뭐냐!?!!
[또언어 구조체..와 비교...!](https://studyc.tistory.com/23)
* 사용자가 여러 값을 묶어서 **유의미한** 데이터 단위를 정의하도록 하는 것❗

## 1. 구조체를 정의하고 생성하기
### 구조체 정의
```rust
// 사용자 계정 정보 저장하는 User 구조체 정의
struct User {
  username: String,
  email: String,
  sign_in_count: u64,
  active: bool,
}
```
* 구조체를 정의하려면 당연히! ```struct```를 먼저 입력해놔야하고, 위의 User와같은 구조체명을 입력
* 중괄호 내의 구성요소는 *field*라 불리며, 타입과 접근 가능한 이름이 정의되어야 함
* 정의를 하고 나서 사용하려면? ➡️ instance(각 필드의 값을 명세한 것) 생성
  * instance는 ```key:value``` 쌍을 중괄호 내에 추가하여 생성 가능
  * instance 사용은 구조체 이름 명시한 것부터 사용 가능한 거라고 보면 됨
<br>

### 구조체 인스턴스 생성
* 구조체 정의: 들어가는 내용의 대략적인 양식
* 인스턴스: 그것에 특정한 값을 넣어 실체화한 것
  * 인스턴스는 반드시 ```변경 가능``` 해야 함
<details>
<summary>구조체 <code>User</code> 인스턴스 생성</summary>
<div markdown="1">
  
```rust
// 특정 사용자 선언
let user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};

```

</details>
<details>
<summary><code>User</code> 인스턴스의 <code>email</code> 필드 변경</summary>
<div markdown="1">

```rust
 let mut user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};

user1.email = String::from("anotheremail@example.com");
```
* ```점(.) 표기법```을 사용하여 특정 필드에 새 값 할당 가능
* Rust에서는 특정 필드만 변경 불가
* 함수 본문 마지막에 새 인스턴스 구조체를 표현식으로 생성하여 새 인스턴스 반환

</details>
<details>
<summary>사용자의 이메일과 이름을 받아 <code>User</code> 구조체의 인스턴스를 반환하는 <code>build_user</code> 함수</summary>
<div markdown="1">

```rust
fn build_user(email: String, username: String) -> User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
```
* active는 ```bool``` 타입의 필드. 사용자 활성 상태를 나타내는 듯..?
  
</details>

* ```User``` 구조체 사용해서 user1이라는 사용자를 생성
* ```build_user``` 함수 호출하여 새로운 ```User``` 인스턴스 생성
<br>

### 필드 초기화 축약법*field init shorthand*
```rust
fn build_user(email: String, username: String) -> User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
```
* 위 build_user 함수와 똑같이 동작
* 매개변수(email, username)가 ```User``` 구조체 필드명과 동일 → 변수 명시 부분 생략 가능.
<br>

### 구조체 갱신법*struct update syntax*
* ⬆️을 이용하여 기존 값을 기반으로 새 구조체 인스턴스 생성❗
```rust
let user2 = User {
    email: String::from("another@example.com"), // 새로 할당
    username: String::from("anotherusername567"), // 새로 할당
    active: user1.active, // user1 값 그대로
    sign_in_count: user1.sign_in_count, // user1 값 그대로
};
```
* ```..구문```을 사용하여 위와 같은 효과를 내는 코드
```rust
// 인스턴스 갱신 문법 사용 예시
let user2 = User {
    email: String::from("another@example.com"),
    username: String::from("anotherusername567"),
    ..user1
};
```
<br>

### 튜플 구조체*tuple struct*
* 필드의 타입만 정의 가능하고 명명은 불가한 구조체 (구조체명으로 의미 부여 가능)
* 1️⃣```struct``` 키워드 2️⃣튜플 타입 정의만 이루어지면 됨❣️
<details>
<summary>예시</summary>
<div markdown="1">

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
```
* 구조체 내의 타입은 동일하지만 ```black```, ```origin``` 각각은 고유의 타입임
</details>
<br>

### 유사 유닛 구조체*unit-like struct*
* 필드가 없음
* [유닛 타입](https://runebook.dev/ko/docs/rust/std/primitive.unit)```()```과 비슷하게 동작.
* 특정한 타입의 trait 구현 요구됨
<br><br>
### 구조체 테이터의 <code>소유권</code>
* [```User``` 구조체 정의](#구조체-정의)에서 ```&str```타입 대신 ```String```타입 사용한 이유는 **전체 구조체가 유효한 동안 구조체가 그 데이터를 소유하도록 하기 위해서**임
* [라이프타임](https://rinthel.github.io/rust-lang-book-ko/ch10-03-lifetime-syntax.html) 사용 전제 시, 구조체가 소유권이 없는 데이터의 참조를 저장할 수 있음 ← 이 내용 잘 모르니까 ```String``` 사용으로 ```&str```사용시의 에러 고치는 것임❗
<br><br>

## 2. 구조체를 이용한 예제 프로그램
1. *rectangles*라는 이름의 새 바이너리 프로젝트 생성
   <details>
   <summary>code examples</summary>
   <div markdown="1"><br>
   
    ```$ cd ~/.firstrust```<br><br>
    ```$ cargo new rectangles --bin```
   
   </details>
2. src/main.rs 파일 수정하기
   <details>
   <summary>more</summary>
   <div markdown="1"><br>
   
    ```rust
    // 길이와 너비가 각각의 변수에 지정된 사각형의 넓이 계산
    
    fn main() {
        let length1 = 50;
        let width1 = 30;
    
        println!(
            "The area of the rectangle is {} square pixels.",
            area(length1, width1)
        );
    }
    
    fn area(length: u32, width: u32) -> u32 {
        length * width
    }
    ```
    * 위 코드 실행 결과<br>
      <img src="https://github.com/redzzzi/Rust23summer/assets/127263392/e053216c-ff32-46db-a514-f57672f645e3" width="500px">
    <br>
    
    ### 튜플을 이용한 리팩터링
    ```rust
    // 튜플을 이용하여 사각형의 길이와 너비 명시
    
    fn main() {
        let rect1 = (50, 30);    // (A, B) 형식 내에 순서대로 length, width를 표기기
    
        println!(
            "The area of the rectangle is {} square pixels.",
            area(rect1)
        );
    }
    
    fn area(dimensions: (u32, u32)) -> u32 {
        dimensions.0 * dimensions.1
    }
    ```
    * 실행 결과는 위와 같음
    * length가 튜플 인덱스 0, width가 튜플 인덱스 1
   
    </details>
    <details>
    <summary>🤓 구조체를 이용한 리팩터링: 의미 추가</summary>
    <div markdown="1">
    
    ```rust
    struct Rectangle {
        length: u32,
        width: u32,
    }
    
    fn main() {
        let rect1 = Rectangle { length: 50, width: 30 };
    
        println!(
            "The area of the rectangle is {} square pixels.",
            area(&rect1)
        );
    }
    
    fn area(rectangle: &Rectangle) -> u32 {
        rectangle.length * rectangle.width
    }
    ```
    * ```struct Rectangle```: Rectangle이라는 이름의 구조체 정의
    * ```length: u32```, ```width: u32```: 각각 필드의 타입 정의
    * main 함수 내에서 Rectangle 구조체의 특정 인스턴스 생성
        * ```let rect1 = Rectangle { length: 50, width: 30 };```: 길이 50, 너비 30의 직사각형 rect1
    * ```fn area(rectangle: &Rectangle)```
        * rectangle이라는 이름의 파라미터 하나를 가진 ```area``` 함수
        * 해당 파라미터는 Rectangle 구조체 인스턴스의 불변 참조자 타입 ← ```&``` 사용
    * ```{ rectangle.lenth * rectangle.width }```
        * 해당 함수는 Rectangle 인스턴스 내의 필드에 접근하여 넓이 계산

    </details>
  
3. derived trait으로 유용한 기능 추가
   <details>
   <summary>디버깅 시 Rectangle 인스턴스 출력하기</summary>
   <div markdown="1">

   ```rust
   #[derive(Debug)]
   struct Rectangle {
       length: u32,
       width: u32,
   }
  
   fn main() {
       let rect1 = Rectangle { length: 50, width: 30 };
  
       println!("rect1 is {:?}", rect1);
   }
   ```
   * ```#[derive(Debug)]``` annotation:<br>
     러스트는 기본적으로 디버깅 정보를 출력하는 기능을 포함하지만,<br>
     **구조체에 대해 해당 기능을 활성화하도록 명시적인 사전동의 필요**  
   * 위 코드 실행 결과<br>
     <img src="https://github.com/redzzzi/Rust23summer/assets/127263392/c9b15f7b-5ad9-42b1-8a4e-8b1f71bd69ad" width="500px"><br>
       * ```rect1 is Rectangle { length: 50, width: 30 }``` 출력 외에도 뭐가 되게 많이 떴음
       * 경고문 내용: lengh, width 필드 사용 안됐으니 필드 제거하거나 쓰이게끔 하라는 뜻인듯..
   * ```💗참고💗``` ```println!``` 스트링 내에 ```{:#?}``` 사용하게 되었을 때의 실행 결과<br><br>
     <img src="https://github.com/redzzzi/Rust23summer/assets/127263392/f63d4398-d5bb-4b94-bfc0-861bd938a3a4" width="400px">


   </details>

    <br><br>
    
     
<br><br>

## 3. 메소드 문법
